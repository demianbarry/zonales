Zcrawling	=     "extraer para la localidad " localidad 
                        [" asignando los tags " tags] 
                        " mediante la fuente " fuente [" ubicada en" uri_fuente]
                        " a partir " criterios 
                        [" incluye comentarios " ["de los usuarios: " usuario *(", " usuario)]]
                        [" y filtrando por " filtros ]
                        [" incluye los tags de la fuente "]
                        ".";
 
localidad	=     char-val; # para toda localidad definida en el arbol de localidades de zonales encerrado entre comillas simple 
tags		=     tag *(", "tag);
tag			=     char-val; # para todo tag (distinto de la zona) definido en la estructura válida de tags de zonales entre comillas simple 
fuente		=     "facebook" / "twitter" / "feed";
uri_fuente	=     %x27 URI %x27; #  formato uri apuntando al url de definición, encerrada entre comilla simples 
criterios	=     criterio *(" y " criterio) ["pero no " criterio *("y " criterio)];
criterio	=     "de todo " /
                        "del usuario " usuario /
                        "de amigos del usuario " usuario /
                        "de las palabras " palabras;
usuario		=     char-val; #  string (palabra) que identifica a un usuario en la fuente (facebook, twitter, linkedin, etc) encerrado entre comillas simple
palabras	=     palabra *(", " palabra);
palabra		=     char-val; #  cualquier palabra 
filtros		=     filtro *("y " filtro);
filtro		=     "al menos" min-num-shuld-match "de las palabras deben estar " /
                        "con una dispercion entre palabras no mayor a " int /
                        "lista negra de usuarios " /
                        "lista negra de palabras " /
                        "con al menos " int "actions ";
min-num-shuld-match = char-val;	# según la especificación y formato de solr 

char-val	=  	DQUOTE *(%x23-7E / %x20) DQUOTE; # quoted string of SP and VCHAR without DQUOTE

ALPHA          =  %x41-5A / %x61-7A; # A-Z / a-z

DQUOTE     =  %x22;

QUOTE      =  "'";

DIGIT		=  %x30-39; #0-9

HEXDIG		=  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"; 
								
int			=	*DIGIT;

URI           = scheme ":" hier-part [ "" query ] [ "#" fragment ];

hier-part     = "//" authority path-abempty
                 / path-absolute
                 / path-rootless
                 / path-empty;

URI-reference = URI / relative-ref;

absolute-URI  = scheme ":" hier-part [ "" query ];

relative-ref  = relative-part [ "" query ] [ "#" fragment ];

relative-part = "//" authority path-abempty
                 / path-absolute
                 / path-noscheme
                 / path-empty;

scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." );

authority     = [ userinfo "@" ] host [ ":" port ];
userinfo      = *( unreserved / pct-encoded / sub-delims / ":" );
host          = IP-literal / IPv4address / reg-name;
port          = *DIGIT;

IP-literal    = "[" ( IPv6address / IPvFuture  ) "]";

IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" );

IPv6address   =                            6( h16 ":" ) ls32
                 /                       "::" 5( h16 ":" ) ls32
                 / [               h16 ] "::" 4( h16 ":" ) ls32
                 / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                 / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                 / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                 / [ *4( h16 ":" ) h16 ] "::"              ls32
                 / [ *5( h16 ":" ) h16 ] "::"              h16
                 / [ *6( h16 ":" ) h16 ] "::";

h16           = 1*4HEXDIG;
ls32          = ( h16 ":" h16 ) / IPv4address;
IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet;
dec-octet     = DIGIT                 # 0-9
                 / %x31-39 DIGIT         # 10-99
                 / "1" 2DIGIT            # 100-199
                 / "2" %x30-34 DIGIT     # 200-249
                 / "25" %x30-35;          # 250-255

reg-name      = *( unreserved / pct-encoded / sub-delims );

path          = path-abempty    # begins with "/" or is empty
                 / path-absolute   # begins with "/" but not "//"
                 / path-noscheme   # begins with a non-colon segment
                 / path-rootless   # begins with a segment
                 / path-empty;      # zero characters

path-abempty  = *( "/" segment );
path-absolute = "/" [ segment-nz *( "/" segment ) ];
path-noscheme = segment-nz-nc *( "/" segment );
path-rootless = segment-nz *( "/" segment );
path-empty    = 0(pchar);

segment       = *pchar;
segment-nz    = 1*pchar;
segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" );
                 # non-zero-length segment without any colon ":";

pchar         = unreserved / pct-encoded / sub-delims / ":" / "@";

query         = *( pchar / "/" / "" );

fragment      = *( pchar / "/" / "" );

pct-encoded   = "%" HEXDIG HEXDIG;

unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~";
reserved      = gen-delims / sub-delims;
gen-delims    = ":" / "/" / "" / "#" / "[" / "]" / "@";
sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
                 / "*" / "+" / "," / "#" / "=";